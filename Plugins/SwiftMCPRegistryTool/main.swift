import Foundation
import SwiftParser
import SwiftSyntax

@main
struct SwiftMCPRegistryTool {
    static func main() throws {
        let args = CommandLine.arguments
        guard args.count >= 3 else {
            fputs("Usage: SwiftMCPRegistryTool <target-name> <output-file> [source-files...]\n", stderr)
            exit(2)
        }

        let targetName = args[1]
        let outputPath = args[2]
        let sourceFiles = Array(args.dropFirst(3))

        let scan = discoverToolsByType(in: sourceFiles)
        let toolsByType = scan.toolsByType
        let importModules = scan.importModules
        let allToolNames = Array(Set(toolsByType.values.flatMap { $0 })).sorted()

        let targetLiteral = swiftStringLiteral(targetName)
        let toolNameLiterals = allToolNames.map(swiftStringLiteral).joined(separator: ", ")
        let toolsByTypeJSON = makeToolsByTypeJSON(toolsByType)
        let toolsByTypeJSONLiteral = swiftStringLiteral(toolsByTypeJSON)

        let registerMethodName = "registerTools"

        let extraImports = importModules
            .filter { $0 != "Foundation" && $0 != "SwiftMCP" }
            .sorted()
            .map { "import \($0)" }
            .joined(separator: "\n")

        var generated = """
        // AUTO-GENERATED by SwiftMCPRegistryTool. DO NOT EDIT.
        import Foundation
        import SwiftMCP
        \(extraImports.isEmpty ? "" : extraImports + "\n")
        public enum __SwiftMCPRegistryPluginGenerated {
            public static let target = \(targetLiteral)
            public static let toolNames: [String] = [\(toolNameLiterals)]
            public static let toolsJSON: String = {
                let data = try! JSONSerialization.data(withJSONObject: toolNames, options: [.sortedKeys])
                return String(data: data, encoding: .utf8)!
            }()
            public static let toolsByTypeJSON: String = \(toolsByTypeJSONLiteral)

            public static func \(registerMethodName)() {
        """

        for typeName in toolsByType.keys.sorted() {
            generated += "\n        __swiftmcp_register_\(sanitizeForIdentifier(typeName))()"
        }

        generated += """
            }
        }

        """

        for (typeName, toolNames) in toolsByType.sorted(by: { $0.key < $1.key }) {
            let fnSuffix = sanitizeForIdentifier(typeName)
            generated += """
            
            private func __swiftmcp_register_\(fnSuffix)() {
            """
            for tool in toolNames.sorted() {
                generated += """
                
                MCPDynamicToolRegistry.register(\(typeName).self, name: \(swiftStringLiteral(tool)), metadata: { server in
                    server.__mcpMetadata_\(tool)
                }, call: { server, args in
                    try await server.__mcpCall_\(tool)(args)
                })
                """
            }
            generated += """
            }
            """
        }

        let outputURL = URL(fileURLWithPath: outputPath)
        try FileManager.default.createDirectory(at: outputURL.deletingLastPathComponent(), withIntermediateDirectories: true)
        try generated.write(to: outputURL, atomically: true, encoding: .utf8)
    }

    private struct ScanResult {
        let toolsByType: [String: [String]]
        let importModules: Set<String>
    }

    private static func discoverToolsByType(in files: [String]) -> ScanResult {
        let collector = ToolCollector(viewMode: .sourceAccurate)

        for file in files {
            guard let text = try? String(contentsOfFile: file, encoding: .utf8) else { continue }
            let source = Parser.parse(source: text)
            collector.walk(source)
        }

        return ScanResult(
            toolsByType: collector.toolsByType.mapValues { Array($0).sorted() },
            importModules: collector.importModules
        )
    }

    private static func makeToolsByTypeJSON(_ toolsByType: [String: [String]]) -> String {
        let normalized = toolsByType
            .mapValues { $0.sorted() }
            .sorted { $0.key < $1.key }
            .reduce(into: [String: [String]]()) { dict, item in
                dict[item.key] = item.value
            }

        let data = try! JSONSerialization.data(withJSONObject: normalized, options: [.sortedKeys])
        return String(data: data, encoding: .utf8)!
    }

    private static func swiftStringLiteral(_ raw: String) -> String {
        let escaped = raw
            .replacingOccurrences(of: "\\", with: "\\\\")
            .replacingOccurrences(of: "\"", with: "\\\"")
        return "\"\(escaped)\""
    }

    private static func sanitizeForIdentifier(_ text: String) -> String {
        var out = text.map { ch -> Character in
            if ch.isLetter || ch.isNumber { return ch }
            return "_"
        }
        if let first = out.first, first.isNumber {
            out.insert("_", at: out.startIndex)
        }
        return String(out)
    }
}

private final class ToolCollector: SyntaxVisitor {
    var toolsByType: [String: Set<String>] = [:]
    var importModules: Set<String> = []
    private var typeStack: [String] = []

    override func visit(_ node: ImportDeclSyntax) -> SyntaxVisitorContinueKind {
        let moduleName = node.path.trimmedDescription
        if !moduleName.isEmpty {
            importModules.insert(moduleName)
        }
        return .skipChildren
    }

    override func visit(_ node: ClassDeclSyntax) -> SyntaxVisitorContinueKind {
        typeStack.append(node.name.text)
        return .visitChildren
    }

    override func visitPost(_ node: ClassDeclSyntax) {
        _ = typeStack.popLast()
    }

    override func visit(_ node: ActorDeclSyntax) -> SyntaxVisitorContinueKind {
        typeStack.append(node.name.text)
        return .visitChildren
    }

    override func visitPost(_ node: ActorDeclSyntax) {
        _ = typeStack.popLast()
    }

    override func visit(_ node: ExtensionDeclSyntax) -> SyntaxVisitorContinueKind {
        typeStack.append(node.extendedType.trimmedDescription)
        return .visitChildren
    }

    override func visitPost(_ node: ExtensionDeclSyntax) {
        _ = typeStack.popLast()
    }

    override func visit(_ node: FunctionDeclSyntax) -> SyntaxVisitorContinueKind {
        guard let owner = typeStack.last else { return .skipChildren }
        guard hasMCPToolAttribute(node) else { return .skipChildren }
        toolsByType[owner, default: []].insert(node.name.text)
        return .skipChildren
    }

    private func hasMCPToolAttribute(_ node: FunctionDeclSyntax) -> Bool {
        for attr in node.attributes {
            guard let attribute = attr.as(AttributeSyntax.self) else { continue }
            let name = attribute.attributeName.trimmedDescription
            if name == "MCPTool" || name.hasSuffix(".MCPTool") {
                return true
            }
        }
        return false
    }
}
