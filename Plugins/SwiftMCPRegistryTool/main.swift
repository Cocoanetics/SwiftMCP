import Foundation
import SwiftParser
import SwiftSyntax

@main
struct SwiftMCPRegistryTool {
    static func main() throws {
        let args = CommandLine.arguments
        guard args.count >= 3 else {
            fputs("Usage: SwiftMCPRegistryTool <target-name> <output-file> [source-files...]\n", stderr)
            exit(2)
        }

        let targetName = args[1]
        let outputPath = args[2]
        let sourceFiles = Array(args.dropFirst(3))

        let scan = discoverContributions(in: sourceFiles)

        let targetLiteral = swiftStringLiteral(targetName)
        let extraImports = scan.importModules
            .filter { $0 != "Foundation" && $0 != "SwiftMCP" }
            .sorted()
            .map { "import \($0)" }
            .joined(separator: "\n")

        let toolNames = Array(Set(scan.toolsByType.values.flatMap { $0 })).sorted()
        let promptNames = Array(Set(scan.promptsByType.values.flatMap { $0 })).sorted()
        let resourceNames = Array(Set(scan.resourcesByType.values.flatMap { $0 })).sorted()

        let toolNameLiterals = toolNames.map(swiftStringLiteral).joined(separator: ", ")
        let promptNameLiterals = promptNames.map(swiftStringLiteral).joined(separator: ", ")
        let resourceNameLiterals = resourceNames.map(swiftStringLiteral).joined(separator: ", ")

        let toolsByTypeJSONLiteral = swiftStringLiteral(makeByTypeJSON(scan.toolsByType))
        let promptsByTypeJSONLiteral = swiftStringLiteral(makeByTypeJSON(scan.promptsByType))
        let resourcesByTypeJSONLiteral = swiftStringLiteral(makeByTypeJSON(scan.resourcesByType))

        var generated = """
        // AUTO-GENERATED by SwiftMCPRegistryTool. DO NOT EDIT.
        import Foundation
        import SwiftMCP
        \(extraImports.isEmpty ? "" : extraImports + "\n")
        public enum __SwiftMCPRegistryPluginGenerated {
            public static let target = \(targetLiteral)

            public static let toolNames: [String] = [\(toolNameLiterals)]
            public static let promptNames: [String] = [\(promptNameLiterals)]
            public static let resourceNames: [String] = [\(resourceNameLiterals)]

            public static let toolsJSON: String = {
                let data = try! JSONSerialization.data(withJSONObject: toolNames, options: [.sortedKeys])
                return String(data: data, encoding: .utf8)!
            }()

            public static let promptsJSON: String = {
                let data = try! JSONSerialization.data(withJSONObject: promptNames, options: [.sortedKeys])
                return String(data: data, encoding: .utf8)!
            }()

            public static let resourcesJSON: String = {
                let data = try! JSONSerialization.data(withJSONObject: resourceNames, options: [.sortedKeys])
                return String(data: data, encoding: .utf8)!
            }()

            public static let toolsByTypeJSON: String = \(toolsByTypeJSONLiteral)
            public static let promptsByTypeJSON: String = \(promptsByTypeJSONLiteral)
            public static let resourcesByTypeJSON: String = \(resourcesByTypeJSONLiteral)

            public static func registerAll() {
                registerTools()
                registerPrompts()
                registerResources()
            }

            public static func registerTools() {
        """

        for typeName in scan.toolsByType.keys.sorted() {
            generated += "\n        __swiftmcp_register_tools_\(sanitizeForIdentifier(typeName))()"
        }

        generated += """
            }

            public static func registerPrompts() {
        """

        for typeName in scan.promptsByType.keys.sorted() {
            generated += "\n        __swiftmcp_register_prompts_\(sanitizeForIdentifier(typeName))()"
        }

        generated += """
            }

            public static func registerResources() {
        """

        for typeName in scan.resourcesByType.keys.sorted() {
            generated += "\n        __swiftmcp_register_resources_\(sanitizeForIdentifier(typeName))()"
        }

        generated += """
            }
        }

        """

        for (typeName, names) in scan.toolsByType.sorted(by: { $0.key < $1.key }) {
            let fnSuffix = sanitizeForIdentifier(typeName)
            generated += """
            private func __swiftmcp_register_tools_\(fnSuffix)() {
            """
            for name in names.sorted() {
                generated += """

                MCPDynamicToolRegistry.register(\(typeName).self, name: \(swiftStringLiteral(name)), metadata: { server in
                    server.__mcpMetadata_\(name)
                }, call: { server, args in
                    try await server.__mcpCall_\(name)(args)
                })
                """
            }
            generated += """
            }

            """
        }

        for (typeName, names) in scan.promptsByType.sorted(by: { $0.key < $1.key }) {
            let fnSuffix = sanitizeForIdentifier(typeName)
            generated += """
            private func __swiftmcp_register_prompts_\(fnSuffix)() {
            """
            for name in names.sorted() {
                generated += """

                MCPDynamicPromptRegistry.register(\(typeName).self, name: \(swiftStringLiteral(name)), metadata: { server in
                    server.__mcpPromptMetadata_\(name)
                }, call: { server, args in
                    try await server.__mcpPromptCall_\(name)(args)
                })
                """
            }
            generated += """
            }

            """
        }

        for (typeName, names) in scan.resourcesByType.sorted(by: { $0.key < $1.key }) {
            let fnSuffix = sanitizeForIdentifier(typeName)
            generated += """
            private func __swiftmcp_register_resources_\(fnSuffix)() {
            """
            for name in names.sorted() {
                generated += """

                MCPDynamicResourceRegistry.register(\(typeName).self, name: \(swiftStringLiteral(name)), metadata: { server in
                    server.__mcpResourceMetadata_\(name)
                }, call: { server, args, requestedUri, overrideMimeType in
                    try await server.__mcpResourceCall_\(name)(args, requestedUri: requestedUri, overrideMimeType: overrideMimeType)
                })
                """
            }
            generated += """
            }

            """
        }

        let outputURL = URL(fileURLWithPath: outputPath)
        try FileManager.default.createDirectory(at: outputURL.deletingLastPathComponent(), withIntermediateDirectories: true)
        try generated.write(to: outputURL, atomically: true, encoding: .utf8)
    }

    private struct ScanResult {
        let toolsByType: [String: [String]]
        let promptsByType: [String: [String]]
        let resourcesByType: [String: [String]]
        let importModules: Set<String>
    }

    private static func discoverContributions(in files: [String]) -> ScanResult {
        let collector = ContributionCollector(viewMode: .sourceAccurate)

        for file in files {
            guard let text = try? String(contentsOfFile: file, encoding: .utf8) else { continue }
            let source = Parser.parse(source: text)
            collector.walk(source)
        }

        return ScanResult(
            toolsByType: collector.toolsByType.mapValues { Array($0).sorted() },
            promptsByType: collector.promptsByType.mapValues { Array($0).sorted() },
            resourcesByType: collector.resourcesByType.mapValues { Array($0).sorted() },
            importModules: collector.importModules
        )
    }

    private static func makeByTypeJSON(_ byType: [String: [String]]) -> String {
        let normalized = byType
            .mapValues { $0.sorted() }
            .sorted { $0.key < $1.key }
            .reduce(into: [String: [String]]()) { dict, item in
                dict[item.key] = item.value
            }

        let data = try! JSONSerialization.data(withJSONObject: normalized, options: [.sortedKeys])
        return String(data: data, encoding: .utf8)!
    }

    private static func swiftStringLiteral(_ raw: String) -> String {
        let escaped = raw
            .replacingOccurrences(of: "\\", with: "\\\\")
            .replacingOccurrences(of: "\"", with: "\\\"")
        return "\"\(escaped)\""
    }

    private static func sanitizeForIdentifier(_ text: String) -> String {
        var out = text.map { ch -> Character in
            if ch.isLetter || ch.isNumber { return ch }
            return "_"
        }
        if let first = out.first, first.isNumber {
            out.insert("_", at: out.startIndex)
        }
        return String(out)
    }
}

private final class ContributionCollector: SyntaxVisitor {
    var toolsByType: [String: Set<String>] = [:]
    var promptsByType: [String: Set<String>] = [:]
    var resourcesByType: [String: Set<String>] = [:]
    var importModules: Set<String> = []

    private var typeStack: [String] = []

    override func visit(_ node: ImportDeclSyntax) -> SyntaxVisitorContinueKind {
        let moduleName = node.path.trimmedDescription
        if !moduleName.isEmpty {
            importModules.insert(moduleName)
        }
        return .skipChildren
    }

    override func visit(_ node: ClassDeclSyntax) -> SyntaxVisitorContinueKind {
        typeStack.append(node.name.text)
        return .visitChildren
    }

    override func visitPost(_ node: ClassDeclSyntax) {
        _ = typeStack.popLast()
    }

    override func visit(_ node: ActorDeclSyntax) -> SyntaxVisitorContinueKind {
        typeStack.append(node.name.text)
        return .visitChildren
    }

    override func visitPost(_ node: ActorDeclSyntax) {
        _ = typeStack.popLast()
    }

    override func visit(_ node: ExtensionDeclSyntax) -> SyntaxVisitorContinueKind {
        typeStack.append(node.extendedType.trimmedDescription)
        return .visitChildren
    }

    override func visitPost(_ node: ExtensionDeclSyntax) {
        _ = typeStack.popLast()
    }

    override func visit(_ node: FunctionDeclSyntax) -> SyntaxVisitorContinueKind {
        guard let owner = typeStack.last else { return .skipChildren }

        if hasAttribute(node, named: "MCPTool") {
            toolsByType[owner, default: []].insert(node.name.text)
        }
        if hasAttribute(node, named: "MCPPrompt") {
            promptsByType[owner, default: []].insert(node.name.text)
        }
        if hasAttribute(node, named: "MCPResource") {
            resourcesByType[owner, default: []].insert(node.name.text)
        }

        return .skipChildren
    }

    private func hasAttribute(_ node: FunctionDeclSyntax, named expectedName: String) -> Bool {
        for attr in node.attributes {
            guard let attribute = attr.as(AttributeSyntax.self) else { continue }
            let name = attribute.attributeName.trimmedDescription
            if name == expectedName || name.hasSuffix(".\(expectedName)") {
                return true
            }
        }
        return false
    }
}
