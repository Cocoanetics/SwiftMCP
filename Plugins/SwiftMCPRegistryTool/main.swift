import Foundation

@main
struct SwiftMCPRegistryTool {
    static func main() throws {
        let args = CommandLine.arguments
        guard args.count >= 3 else {
            fputs("Usage: SwiftMCPRegistryTool <target-name> <output-file> [source-files...]\n", stderr)
            exit(2)
        }

        let targetName = args[1]
        let outputPath = args[2]
        let sourceFiles = Array(args.dropFirst(3))

        let toolNames = discoverToolNames(in: sourceFiles)
        let escapedTarget = targetName.replacingOccurrences(of: "\\", with: "\\\\").replacingOccurrences(of: "\"", with: "\\\"")
        let toolNameLiterals = toolNames.map { "\"\($0.replacingOccurrences(of: "\\", with: "\\\\").replacingOccurrences(of: "\"", with: "\\\""))\"" }.joined(separator: ", ")

        let generated = """
        // AUTO-GENERATED by SwiftMCPRegistryTool. DO NOT EDIT.
        import Foundation

        public enum __SwiftMCPRegistryPluginGenerated {
            public static let target = \"\(escapedTarget)\"
            public static let toolNames: [String] = [\(toolNameLiterals)]
            public static let toolsJSON: String = {
                let data = try! JSONSerialization.data(withJSONObject: toolNames, options: [.sortedKeys])
                return String(data: data, encoding: .utf8)!
            }()
        }
        """

        let outputURL = URL(fileURLWithPath: outputPath)
        try FileManager.default.createDirectory(at: outputURL.deletingLastPathComponent(), withIntermediateDirectories: true)
        try generated.write(to: outputURL, atomically: true, encoding: .utf8)
    }

    private static func discoverToolNames(in files: [String]) -> [String] {
        let pattern = "@MCPTool(?:\\s*\\([^)]*\\))?\\s*(?:public\\s+|internal\\s+|private\\s+|fileprivate\\s+|open\\s+)?(?:nonisolated\\s+)?(?:final\\s+)?func\\s+([A-Za-z_][A-Za-z0-9_]*)"
        guard let regex = try? NSRegularExpression(pattern: pattern, options: [.dotMatchesLineSeparators]) else {
            return []
        }

        var all: [String] = []
        for file in files {
            guard let text = try? String(contentsOfFile: file, encoding: .utf8) else { continue }
            let range = NSRange(text.startIndex..<text.endIndex, in: text)
            for match in regex.matches(in: text, options: [], range: range) {
                guard match.numberOfRanges >= 2,
                      let r = Range(match.range(at: 1), in: text)
                else { continue }
                all.append(String(text[r]))
            }
        }

        return Array(Set(all)).sorted()
    }
}
