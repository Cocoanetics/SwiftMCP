import Foundation
import SwiftDiagnostics
import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros

/**
 Implementation of the Schema macro.
 
 This macro transforms a struct into a schema by generating metadata about its properties.
 
 Example usage:
 ```swift
 /// A person's contact information
 @Schema
 struct ContactInfo {
     /// The person's full name
     let name: String
     
     /// The person's email address
     let email: String
     
     /// The person's phone number (optional)
     let phone: String?
     
     /// The person's age
     let age: Int = 0
     
     /// The person's address
     let address: Address
 }
 
 /// A person's address
 @Schema
 struct Address {
     /// The street name
     let street: String
     
     /// The city name
     let city: String
 }
 ```
 
 - Note: The macro extracts documentation from the struct's comments for:
   * Struct description
   * Property descriptions
 
 - Attention: The macro will emit diagnostics for:
   * Non-struct declarations
 */
public struct SchemaMacro: MemberMacro, ExtensionMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingMembersOf declaration: some DeclGroupSyntax,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        // Handle struct declarations
        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            let diagnostic = Diagnostic(node: node, message: SchemaDiagnostic.onlyStructs)
            context.diagnose(diagnostic)
            return []
        }
        
        // Extract struct name
        let structName = structDecl.name.text
        
        // Extract property descriptions from documentation
        let documentation = Documentation(from: structDecl.leadingTrivia.description)
        
        // Extract property information
        var propertyString = ""
        var propertyInfos: [(name: String, type: String, defaultValue: String?)] = []
        
        // Process all members including nested structs
        for member in structDecl.memberBlock.members {
            if let property = member.decl.as(VariableDeclSyntax.self) {
                // Process regular property
                let (propertyStr, propertyInfo) = try processProperty(
                    property: property,
                    documentation: documentation,
                    context: context
                )
                
                if !propertyString.isEmpty {
                    propertyString += ", "
                }
                propertyString += propertyStr
                propertyInfos.append(propertyInfo)
            } else if let nestedStruct = member.decl.as(StructDeclSyntax.self) {
                // Process nested struct
                let nestedSchema = try processNestedStruct(nestedStruct, context: context)
                propertyString += nestedSchema
            }
        }
        
        // Create a registration statement
        let registrationDecl = """
        ///
        /// autogenerated
        public static var schema: JSONSchema {
        	let metadata = SchemaMetadata(
        		name: "\(structName)",
        		description: \(documentation.description.isEmpty ? "nil" : "\"\(documentation.description.escapedForSwiftString)\""),
        		parameters: [\(propertyString)]
        	)
        
        	return metadata.schema
        }
        """
        
        return [DeclSyntax(stringLiteral: registrationDecl)]
    }
    
    public static func expansion(
        of node: AttributeSyntax,
        attachedTo declaration: some DeclGroupSyntax,
        providingExtensionsOf type: some TypeSyntaxProtocol,
        conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [ExtensionDeclSyntax] {
        // Check if the declaration already conforms to SchemaRepresentable
        let inheritedTypes = declaration.inheritanceClause?.inheritedTypes ?? []
        let alreadyConformsToSchemaRepresentable = inheritedTypes.contains { type in
            type.type.trimmedDescription == "SchemaRepresentable"
        }
        
        // If it already conforms, don't add the conformance again
        if alreadyConformsToSchemaRepresentable {
            return []
        }
        
        // Create an extension that adds the SchemaRepresentable protocol conformance
        let extensionDecl = try ExtensionDeclSyntax("extension \(type): SchemaRepresentable {}")
        
        return [extensionDecl]
    }
    
    private static func processProperty(
        property: VariableDeclSyntax,
        documentation: Documentation,
        context: MacroExpansionContext
    ) throws -> (String, (name: String, type: String, defaultValue: String?)) {
        // Get the property name and type
        let propertyName = property.bindings.first?.pattern.as(IdentifierPatternSyntax.self)?.identifier.text ?? ""
        let propertyType = property.bindings.first?.typeAnnotation?.type.description.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines) ?? ""
        
        // Get property description from property's documentation
        var propertyDescription = "nil"
        let propertyDoc = Documentation(from: property.leadingTrivia.description)
        if !propertyDoc.description.isEmpty {
            propertyDescription = "\"\(propertyDoc.description.escapedForSwiftString)\""
        }
        
        // Check for default value
        var defaultValue = "nil"
        if let initializer = property.bindings.first?.initializer {
            let rawValue = initializer.value.description.trimmingCharacters(in: CharacterSet.whitespaces)
            
            // Handle different types of default values
            if rawValue.hasPrefix(".") {
                defaultValue = "\(propertyType)\(rawValue)"
            } else if rawValue.contains(".") || 
                      rawValue == "true" || rawValue == "false" ||
                      Double(rawValue) != nil ||
                      rawValue == "nil" ||
                      (rawValue.hasPrefix("[") && rawValue.hasSuffix("]")) {
                defaultValue = rawValue
            } else if let stringLiteral = initializer.value.as(StringLiteralExprSyntax.self) {
                defaultValue = "\"\(stringLiteral.segments.description)\""
            } else {
                defaultValue = "\"\(rawValue)\""
            }
        }
        
        // Create property info with isRequired property
        let isOptionalType = propertyType.hasSuffix("?") || propertyType.hasSuffix("!")
        let isRequired = defaultValue == "nil" && !isOptionalType
        
        // Strip optional marker from type for JSON schema
        let baseType = isOptionalType ? String(propertyType.dropLast()) : propertyType
        
        // Create parameter info with the type directly
        let propertyStr = "SchemaPropertyInfo(name: \"\(propertyName)\", type: \(baseType).self, description: \(propertyDescription), defaultValue: \(defaultValue), isRequired: \(isRequired))"
        
        return (propertyStr, (name: propertyName, type: propertyType, defaultValue: defaultValue))
    }
    
    private static func processNestedStruct(
        _ structDecl: StructDeclSyntax,
        context: MacroExpansionContext
    ) throws -> String {
        let structName = structDecl.name.text
        let documentation = Documentation(from: structDecl.leadingTrivia.description)
        
        var propertyString = ""
        
        // Process properties of nested struct
        for member in structDecl.memberBlock.members {
            if let property = member.decl.as(VariableDeclSyntax.self) {
                let (propertyStr, _) = try processProperty(
                    property: property,
                    documentation: documentation,
                    context: context
                )
                
                if !propertyString.isEmpty {
                    propertyString += ", "
                }
                propertyString += propertyStr
            }
        }
        
        // Create metadata for nested struct
        return """
        , SchemaPropertyInfo(
            name: "\(structName)",
            type: "\(structName)",
            type: \(structName).self,
            description: \(documentation.description.isEmpty ? "nil" : "\"\(documentation.description.escapedForSwiftString)\""),
            defaultValue: nil,
            enumValues: nil,
            isRequired: true
        )
        """
    }
}

// Diagnostic messages for the Schema macro
enum SchemaDiagnostic: DiagnosticMessage {
    case onlyStructs
    
    var message: String {
        switch self {
        case .onlyStructs:
            return "@Schema can only be applied to struct declarations"
        }
    }
    
    var diagnosticID: MessageID {
        switch self {
        case .onlyStructs:
            return MessageID(domain: "SchemaMacro", id: "onlyStructs")
        }
    }
    
    var severity: DiagnosticSeverity {
        switch self {
        case .onlyStructs:
            return .error
        }
    }
} 
