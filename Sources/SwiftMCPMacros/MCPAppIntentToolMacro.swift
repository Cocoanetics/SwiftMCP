//
//  MCPAppIntentToolMacro.swift
//  SwiftMCPMacros
//
//  Created by Oliver Drobnik on 19.03.25.
//

import Foundation
import SwiftDiagnostics
import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros

/// Implementation of the MCPAppIntentTool macro.
public struct MCPAppIntentToolMacro: MemberMacro, ExtensionMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingMembersOf declaration: some DeclGroupSyntax,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        guard let typeName = typeName(from: declaration) else { return [] }
        guard isAppIntentDeclaration(declaration) else {
            let diagnostic = Diagnostic(node: Syntax(node), message: MCPToolDiagnostic.requiresAppIntentConformance(typeName: typeName))
            context.diagnose(diagnostic)
            return []
        }

        let documentation = Documentation(from: declaration.leadingTrivia.description)

        var descriptionArg = "nil"
        var isConsequentialArg = "true"

        if let arguments = node.arguments?.as(LabeledExprListSyntax.self) {
            for argument in arguments {
                if argument.label?.text == "description",
                   let stringLiteral = argument.expression.as(StringLiteralExprSyntax.self) {
                    let stringValue = stringLiteral.segments.description
                    descriptionArg = "\"\(stringValue.escapedForSwiftString)\""
                } else if argument.label?.text == "isConsequential",
                          let boolLiteral = argument.expression.as(BooleanLiteralExprSyntax.self) {
                    isConsequentialArg = boolLiteral.literal.text
                }
            }
        }

        if descriptionArg == "nil", !documentation.description.isEmpty {
            descriptionArg = "\"\(documentation.description.escapedForSwiftString)\""
        }

        let parameters = appIntentParameters(from: declaration)
        let parameterInfoStrings = parameters.map { $0.toMCPParameterInfo() }

        let metadataDeclaration = """
/// Metadata for the \(typeName) tool
public static let mcpToolMetadata = MCPToolMetadata(
   name: "\(typeName)",
   description: \(descriptionArg),
   parameters: [\(parameterInfoStrings.joined(separator: ", "))],
   returnType: Void.self,
   returnTypeDescription: nil,
   isAsync: true,
   isThrowing: true,
   isConsequential: \(isConsequentialArg)
)
"""

        var performMethod = """

/// Autogenerated AppIntent wrapper for \(typeName)
public static func mcpPerform(arguments: [String: Sendable]) async throws -> (Encodable & Sendable) {
   let intent = Self()
"""

        for param in parameters {
            performMethod += """

   intent.\(param.name) = try arguments.extractValue(named: "\(param.name)", as: \(param.typeString).self)
"""
        }

        performMethod += """

   _ = try await intent.perform()
   return ""
}
"""

        return [
            DeclSyntax(stringLiteral: metadataDeclaration),
            DeclSyntax(stringLiteral: performMethod)
        ]
    }

    public static func expansion(
        of node: AttributeSyntax,
        providingMembersOf declaration: some DeclGroupSyntax,
        conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        try expansion(of: node, providingMembersOf: declaration, in: context)
    }

    public static func expansion(
        of node: AttributeSyntax,
        attachedTo declaration: some DeclGroupSyntax,
        providingExtensionsOf type: some TypeSyntaxProtocol,
        conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [ExtensionDeclSyntax] {
        let inheritedTypes = declaration.inheritanceClause?.inheritedTypes ?? []
        let alreadyConforms = inheritedTypes.contains { type in
            type.type.trimmedDescription == "MCPAppIntentTool"
        }
        if alreadyConforms { return [] }

        let extensionDecl = try ExtensionDeclSyntax("extension \(type): MCPAppIntentTool {}")
        return [extensionDecl]
    }

    private struct AppIntentParameter {
        let name: String
        let typeString: String
        let baseTypeString: String
        let defaultValueForMetadata: String
        let description: String?
        let isOptionalType: Bool

        func toMCPParameterInfo() -> String {
            let descriptionString = description ?? "nil"
            let isRequired = defaultValueForMetadata == "nil" && !isOptionalType
            return "MCPParameterInfo(name: \"\(name)\", type: \(baseTypeString).self, description: \(descriptionString), defaultValue: \(defaultValueForMetadata), isRequired: \(isRequired))"
        }
    }

    private static func typeName(from declaration: some DeclGroupSyntax) -> String? {
        if let structDecl = declaration.as(StructDeclSyntax.self) {
            return structDecl.name.text
        }
        if let classDecl = declaration.as(ClassDeclSyntax.self) {
            return classDecl.name.text
        }
        if let actorDecl = declaration.as(ActorDeclSyntax.self) {
            return actorDecl.name.text
        }
        return nil
    }

    private static func isAppIntentDeclaration(_ declaration: some DeclGroupSyntax) -> Bool {
        let inheritedTypes = declaration.inheritanceClause?.inheritedTypes ?? []
        return inheritedTypes.contains { type in
            let name = type.type.trimmedDescription
            return name == "AppIntent" || name.hasSuffix(".AppIntent")
        }
    }

    private static func appIntentParameters(from declaration: some DeclGroupSyntax) -> [AppIntentParameter] {
        var parameters: [AppIntentParameter] = []

        for member in declaration.memberBlock.members {
            guard let varDecl = member.decl.as(VariableDeclSyntax.self) else { continue }
            guard let parameterAttribute = varDecl.attributes.compactMap({ $0.as(AttributeSyntax.self) }).first(where: {
                guard let identifier = $0.attributeName.as(IdentifierTypeSyntax.self) else { return false }
                return identifier.name.text == "Parameter"
            }) else {
                continue
            }

            for binding in varDecl.bindings {
                guard let pattern = binding.pattern.as(IdentifierPatternSyntax.self) else { continue }
                guard let typeSyntax = binding.typeAnnotation?.type else { continue }

                let name = pattern.identifier.text
                let typeString = typeSyntax.description.trimmingCharacters(in: .whitespacesAndNewlines)
                let isOptionalType = typeSyntax.is(OptionalTypeSyntax.self) ||
                    typeSyntax.is(ImplicitlyUnwrappedOptionalTypeSyntax.self) ||
                    typeString.hasSuffix("?") ||
                    typeString.hasSuffix("!")

                let baseTypeString: String
                if isOptionalType {
                    if typeString.hasSuffix("?") || typeString.hasSuffix("!") {
                        baseTypeString = String(typeString.dropLast())
                    } else if let optType = typeSyntax.as(OptionalTypeSyntax.self) {
                        baseTypeString = optType.wrappedType.description.trimmingCharacters(in: .whitespacesAndNewlines)
                    } else if let iuoType = typeSyntax.as(ImplicitlyUnwrappedOptionalTypeSyntax.self) {
                        baseTypeString = iuoType.wrappedType.description.trimmingCharacters(in: .whitespacesAndNewlines)
                    } else {
                        baseTypeString = typeString
                    }
                } else {
                    baseTypeString = typeString
                }

                let propertyDoc = Documentation(from: varDecl.leadingTrivia.description)
                var description: String? = nil
                if !propertyDoc.description.isEmpty {
                    description = "\"\(propertyDoc.description.escapedForSwiftString)\""
                } else if let title = parameterTitle(from: parameterAttribute) {
                    description = "\"\(title.escapedForSwiftString)\""
                }

                let defaultValueExpr = binding.initializer?.value
                let defaultValueForMetadata = processDefaultValue(
                    defaultValueExpr,
                    paramTypeString: baseTypeString,
                    isArray: typeSyntax.is(ArrayTypeSyntax.self) || typeString.hasPrefix("[")
                )

                parameters.append(AppIntentParameter(
                    name: name,
                    typeString: typeString,
                    baseTypeString: baseTypeString,
                    defaultValueForMetadata: defaultValueForMetadata,
                    description: description,
                    isOptionalType: isOptionalType
                ))
            }
        }

        return parameters
    }

    private static func parameterTitle(from attribute: AttributeSyntax) -> String? {
        guard let arguments = attribute.arguments?.as(LabeledExprListSyntax.self) else { return nil }

        for argument in arguments {
            if argument.label?.text == "title" || argument.label == nil {
                if let stringLiteral = argument.expression.as(StringLiteralExprSyntax.self) {
                    return stringLiteral.segments.description
                }
            }
        }
        return nil
    }

    private static func processDefaultValue(
        _ defaultExpr: ExprSyntax?,
        paramTypeString: String,
        isArray: Bool
    ) -> String {
        guard let expr = defaultExpr else { return "nil" }

        let rawValue = expr.description.trimmingCharacters(in: .whitespaces)

        if expr.is(NilLiteralExprSyntax.self) {
            return "nil"
        } else if let stringLiteral = expr.as(StringLiteralExprSyntax.self) {
            return "\"\(stringLiteral.segments.description.escapedForSwiftString)\""
        } else if expr.is(BooleanLiteralExprSyntax.self) ||
                    expr.is(IntegerLiteralExprSyntax.self) ||
                    expr.is(FloatLiteralExprSyntax.self) {
            return rawValue
        } else if rawValue.hasPrefix(".") {
            return "\(paramTypeString)\(rawValue)"
        } else if expr.is(ArrayExprSyntax.self) && rawValue == "[]" {
            if isArray {
                return "[] as \(paramTypeString)"
            }
            return "[]"
        }

        return rawValue
    }
}
