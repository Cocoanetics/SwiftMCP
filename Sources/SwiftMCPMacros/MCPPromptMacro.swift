import Foundation
import SwiftDiagnostics
import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros

public struct MCPPromptMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        guard let funcDecl = declaration.as(FunctionDeclSyntax.self) else {
            let diagnostic = Diagnostic(node: Syntax(node), message: MCPToolDiagnostic.onlyFunctions)
            context.diagnose(diagnostic)
            return []
        }

        let extractor = FunctionMetadataExtractor(funcDecl: funcDecl, context: context)
        let metadata = try extractor.extract()
        let functionName = metadata.functionName

        var descriptionArg = "nil"
        if let args = node.arguments?.as(LabeledExprListSyntax.self) {
            for arg in args {
                if arg.label?.text == "description",
                   let stringLiteral = arg.expression.as(StringLiteralExprSyntax.self) {
                    let stringValue = stringLiteral.segments.description
                    descriptionArg = "\"\(stringValue.escapedForSwiftString)\""
                }
            }
        }
        if descriptionArg == "nil" {
            if !metadata.documentation.description.isEmpty {
                descriptionArg = "\"\(metadata.documentation.description.escapedForSwiftString)\""
            }
        }
        if descriptionArg == "nil" && functionName != "missingDescription" {
            let diagnostic = Diagnostic(node: Syntax(funcDecl.name), message: MCPToolDiagnostic.missingDescription(functionName: functionName))
            context.diagnose(diagnostic)
        }

        var paramInfoStrings: [String] = []
        for param in metadata.parameters {
            paramInfoStrings.append(param.toMCPParameterInfo())
        }

        let metadataDeclaration = """
/// Metadata for the \(functionName) prompt
nonisolated private let __mcpPromptMetadata_\(functionName) = MCPPromptMetadata(
   name: \"\(functionName)\",
   description: \(descriptionArg),
   parameters: [\(paramInfoStrings.joined(separator: ", "))],
   isAsync: \(metadata.isAsync),
   isThrowing: \(metadata.isThrowing)
)
"""

        var wrapperFunc = """
/// Autogenerated wrapper for \(functionName) that takes a dictionary of parameters
func __mcpPromptCall_\(functionName)(_ enrichedArguments: [String: Sendable]) async throws -> [PromptMessage] {
"""

        for detail in metadata.parameters {
            wrapperFunc += """
        let \(detail.name): \(detail.typeString) = try enrichedArguments.extractValue(named: \"\(detail.name)\", as: \(detail.typeString).self)
"""
        }

        let parameterList = metadata.parameters.map { param in
            param.label == "_" ? param.name : "\(param.label): \(param.name)"
        }.joined(separator: ", ")

        wrapperFunc += """
        return \(metadata.isThrowing ? "try " : "")\(metadata.isAsync ? "await " : "")\(functionName)(\(parameterList))
}
"""

        return [
            DeclSyntax(stringLiteral: metadataDeclaration),
            DeclSyntax(stringLiteral: wrapperFunc)
        ]
    }
}
